-- ==============================================================
-- FILE : V2_RD_6F.VHD  -  DO NOT EDIT THIS FILE
-- ==============================================================
--
-- This file is part of the Hardware Interface Layer (H.I.L) of
-- your project when using your HERON-FPGA3 module.
--
-- This file must NOT be modified by users of the Module.
-- 
-- ==============================================================
--
--  Module      : HE_RD_6F
--  Date        : 25/03/2002
--  Author      : R. Williams - HUNT ENGINEERING
--  Description : Input FIFO interface, for 6 FIFOs
--
-- ==============================================================
--
--  Ver     Modified By      Date      Changes
--  ---     -----------      ----      -------
--  1.0     R. Williams    28-02-02    First Written
--  1.1     R. Williams    08-05-02    Syntax change made to all
--                                     instanciated components,
--                                     (changed '0' to GND)
--                                     for compatibility with
--                                     ModelSim5.5b.
--  1.2     R. Williams    11-06-02    Added 1ns delay on paths
--                                     from inferred flip-flops
--                                     to instantiated flip-flops
--                                     to prevent setup violations
--                                     in functional simulation.
--  2.0     R. Williams    10-10-02    New components added for
--                                     interfacing to all six HERON
--                                     input FIFOs and all six HERON
--                                     output FIFOs at the same time.
--                                     Added component HE_RD_6F in
--                                     place of component HE_RD_1F.
--                                     Added component HE_WR_6F in
--                                     place of component HE_WR_1F.
--  2.1     R. Williams    20-01-03    Changes made to the HSB
--                                     mastering functions, and 
--                                     additional registering added
--                                     to the AE flag to ensure
--                                     correct reading from HEPC8s.
--  2.2     R. Williams    13-03-03    Modified use of translate
--                                     statements for compatibility
--                                     with Synplify. Copy made of
--                                     V2_RD_6F with Virtex2 library
--                                     declared and copy made of
--                                     S2_RD_6F with Virtex library
--                                     declared, as required by
--                                     Synplify.
--  2.3     R. Williams    10-08-03    Corrected problem found in
--                                     Six FIFO Read interface that
--                                     caused data errors when using
--                                     rotating read-requests.
--
-- ==============================================================


library IEEE;
  use IEEE.std_logic_1164.all;

-- pragma translate_off
library UNISIM;
  use UNISIM.vcomponents.all;
-- pragma translate_on

entity HE_RD_6F is
  port (
    -- External PADS - HE_IO_CI
    DIF_EF          : in  std_logic_vector(5 downto 0);
    DIF_AE          : in  std_logic_vector(5 downto 0);
    DIF_REN         : out std_logic_vector(5 downto 0);
    DIF_OEN         : out std_logic_vector(5 downto 0);
    -- External PADS - HE_IO_DI
    DI              : in  std_logic_vector(31 downto 0);
    -- Module I/Os
    RST             : in  std_logic;
    CLK             : in  std_logic;
    INFIFO_READ_REQ : in  std_logic_vector(5 downto 0);
    INFIFO_DVALID   : out std_logic_vector(5 downto 0);
    INFIFO_SINGLE   : out std_logic_vector(5 downto 0);
    INFIFO_BURST    : out std_logic_vector(5 downto 0);
    INFIFO0_D       : out std_logic_vector(31 downto 0);
    INFIFO1_D       : out std_logic_vector(31 downto 0);
    INFIFO2_D       : out std_logic_vector(31 downto 0);
    INFIFO3_D       : out std_logic_vector(31 downto 0);
    INFIFO4_D       : out std_logic_vector(31 downto 0);
    INFIFO5_D       : out std_logic_vector(31 downto 0)
  );
end HE_RD_6F;



architecture RTL of HE_RD_6F is

  component lut2    -- two input Look Up Table
    --pragma translate_off
    generic (
      init : bit_vector);
   --pragma translate_on
    port (
      i0 : in  std_logic;
      i1 : in  std_logic;
      o  : out std_logic
    );
  end component;

  component lut3    -- three input Look Up Table
    --pragma translate_off
    generic (
      init : bit_vector);
   --pragma translate_on
    port (
      i0 : in  std_logic;
      i1 : in  std_logic;
      i2 : in  std_logic;
      o  : out std_logic
    );
  end component;

  component lut4    -- four input Look Up Table
    --pragma translate_off
    generic (
      init : bit_vector);
   --pragma translate_on
    port (
      i0 : in  std_logic;
      i1 : in  std_logic;
      i2 : in  std_logic;
      i3 : in  std_logic;
      o  : out std_logic
    );
  end component;

  component lut4_l  -- four input Look Up Table
    --pragma translate_off
    generic (
      init : bit_vector);
   --pragma translate_on
    port (
      i0 : in  std_logic;
      i1 : in  std_logic;
      i2 : in  std_logic;
      i3 : in  std_logic;
      lo : out std_logic
    );
  end component;

  component FD
    port(
      Q   : out std_logic;
      D   : in  std_logic;
      C   : in  std_logic );
  end component;

  component FDC
    port(
      Q   : out std_logic;
      D   : in  std_logic;
      C   : in  std_logic;
      CLR : in  std_logic );
  end component;

  component FDCE
    port(
      Q   : out std_logic;
      D   : in  std_logic;
      C   : in  std_logic;
      CE  : in  std_logic;
      CLR : in  std_logic );
  end component;

  component FDPE
    port(
      Q   : out std_logic;
      D   : in  std_logic;
      C   : in  std_logic;
      CE  : in  std_logic;
      PRE : in  std_logic );
  end component;

  component MUXCY_L
    port(
      LO : out std_logic;
      DI : in  std_logic;
      CI : in  std_logic;
      S  : in  std_logic );
  end component;

  -- Note : attributes on instances are supported by all synthesis tools.

  attribute LOC : string;
  attribute IOB : string;

  attribute LOC of iEF0  : label is "V9";
  attribute LOC of iEF1  : label is "AB9";
  attribute LOC of iEF2  : label is "V10";
  attribute LOC of iEF3  : label is "AA9";
  attribute LOC of iEF4  : label is "W10";
  attribute LOC of iEF5  : label is "Y10";

  attribute LOC of iAE0  : label is "V11";
  attribute LOC of iAE1  : label is "W11";
  attribute LOC of iAE2  : label is "U11";
  attribute LOC of iAE3  : label is "Y12";
  attribute LOC of iAE4  : label is "AA12";
  attribute LOC of iAE5  : label is "W13";

  attribute LOC of iDI0  : label is "V8";
  attribute LOC of iDI1  : label is "AA5";
  attribute LOC of iDI2  : label is "AB5";
  attribute LOC of iDI3  : label is "Y7";
  attribute LOC of iDI4  : label is "W6";
  attribute LOC of iDI5  : label is "Y6";
  attribute LOC of iDI6  : label is "V7";
  attribute LOC of iDI7  : label is "Y2";
  attribute LOC of iDI8  : label is "W2";
  attribute LOC of iDI9  : label is "U4";
  attribute LOC of iDI10 : label is "Y1";
  attribute LOC of iDI11 : label is "V2";
  attribute LOC of iDI12 : label is "W1";
  attribute LOC of iDI13 : label is "T4";
  attribute LOC of iDI14 : label is "T3";
  attribute LOC of iDI15 : label is "U2";
  attribute LOC of iDI16 : label is "V1";
  attribute LOC of iDI17 : label is "U1";
  attribute LOC of iDI18 : label is "T2";
  attribute LOC of iDI19 : label is "R4";
  attribute LOC of iDI20 : label is "T1";
  attribute LOC of iDI21 : label is "P3";
  attribute LOC of iDI22 : label is "P5";
  attribute LOC of iDI23 : label is "P4";
  attribute LOC of iDI24 : label is "N5";
  attribute LOC of iDI25 : label is "N4";
  attribute LOC of iDI26 : label is "N3";
  attribute LOC of iDI27 : label is "N2";
  attribute LOC of iDI28 : label is "M5";
  attribute LOC of iDI29 : label is "N1";
  attribute LOC of iDI30 : label is "M6";
  attribute LOC of iDI31 : label is "M1";

  attribute IOB of iEF0  : label is "TRUE";
  attribute IOB of iEF1  : label is "TRUE";
  attribute IOB of iEF2  : label is "TRUE";
  attribute IOB of iEF3  : label is "TRUE";
  attribute IOB of iEF4  : label is "TRUE";
  attribute IOB of iEF5  : label is "TRUE";

  attribute IOB of iAE0  : label is "TRUE";
  attribute IOB of iAE1  : label is "TRUE";
  attribute IOB of iAE2  : label is "TRUE";
  attribute IOB of iAE3  : label is "TRUE";
  attribute IOB of iAE4  : label is "TRUE";
  attribute IOB of iAE5  : label is "TRUE";

  attribute IOB of iRE0  : label is "TRUE";
  attribute IOB of iRE1  : label is "TRUE";
  attribute IOB of iRE2  : label is "TRUE";
  attribute IOB of iRE3  : label is "TRUE";
  attribute IOB of iRE4  : label is "TRUE";
  attribute IOB of iRE5  : label is "TRUE";

  attribute IOB of iDI0  : label is "TRUE";
  attribute IOB of iDI1  : label is "TRUE";
  attribute IOB of iDI2  : label is "TRUE";
  attribute IOB of iDI3  : label is "TRUE";
  attribute IOB of iDI4  : label is "TRUE";
  attribute IOB of iDI5  : label is "TRUE";
  attribute IOB of iDI6  : label is "TRUE";
  attribute IOB of iDI7  : label is "TRUE";

  attribute IOB of iDI8  : label is "TRUE";
  attribute IOB of iDI9  : label is "TRUE";
  attribute IOB of iDI10 : label is "TRUE";
  attribute IOB of iDI11 : label is "TRUE";
  attribute IOB of iDI12 : label is "TRUE";
  attribute IOB of iDI13 : label is "TRUE";
  attribute IOB of iDI14 : label is "TRUE";
  attribute IOB of iDI15 : label is "TRUE";

  attribute IOB of iDI16 : label is "TRUE";
  attribute IOB of iDI17 : label is "TRUE";
  attribute IOB of iDI18 : label is "TRUE";
  attribute IOB of iDI19 : label is "TRUE";
  attribute IOB of iDI20 : label is "TRUE";
  attribute IOB of iDI21 : label is "TRUE";
  attribute IOB of iDI22 : label is "TRUE";
  attribute IOB of iDI23 : label is "TRUE";

  attribute IOB of iDI24 : label is "TRUE";
  attribute IOB of iDI25 : label is "TRUE";
  attribute IOB of iDI26 : label is "TRUE";
  attribute IOB of iDI27 : label is "TRUE";
  attribute IOB of iDI28 : label is "TRUE";
  attribute IOB of iDI29 : label is "TRUE";
  attribute IOB of iDI30 : label is "TRUE";
  attribute IOB of iDI31 : label is "TRUE";

  signal GND       : std_logic;
  -- Read Enable logic
  signal RENc      : std_logic_vector(5 downto 0);
  signal REN       : std_logic_vector(5 downto 0);
  signal RD_OK     : std_logic_vector(5 downto 0);
  signal RD_WAc    : std_logic_vector(5 downto 0);
  signal RD_WA     : std_logic_vector(5 downto 0);
  signal RD_WBc    : std_logic_vector(5 downto 0);
  signal RD_WB     : std_logic_vector(5 downto 0);
  signal EF_REG    : std_logic_vector(5 downto 0);
  signal AE_REG    : std_logic_vector(5 downto 0);
  signal AE_IFF    : std_logic_vector(5 downto 0);
  signal AE_DEL    : std_logic_vector(5 downto 0);
  -- Data Valid logic
  signal DIVc      : std_logic;
  signal DIV       : std_logic;
  signal DIVv      : std_logic_vector(5 downto 0);
  signal IRVc      : std_logic_vector(5 downto 0);
  signal IRV       : std_logic_vector(5 downto 0);
  signal DRAVc     : std_logic_vector(5 downto 0);
  signal DRAV      : std_logic_vector(5 downto 0);
  signal DRBVc     : std_logic_vector(5 downto 0);
  signal DRBV      : std_logic_vector(5 downto 0);
  signal DVALIDc   : std_logic_vector(5 downto 0);
  signal DVALID    : std_logic_vector(5 downto 0);
  -- Register Enable logic
  signal IR_A      : std_logic;
  signal IR_B      : std_logic;
  signal IR_C      : std_logic;
  signal IR_D      : std_logic;
  signal IR_E      : std_logic;
  signal IR_F      : std_logic;
  signal IR_G      : std_logic;
  signal IR_CE     : std_logic;
  signal IR_CE_B   : std_logic;
  signal IR_CE_C   : std_logic;
  signal IR_CEv    : std_logic_vector(5 downto 0);
  signal DRA_CE    : std_logic_vector(5 downto 0);
  signal DRB_CE    : std_logic_vector(5 downto 0);
  signal SELc      : std_logic_vector(5 downto 0);
  signal SEL       : std_logic_vector(5 downto 0);
  -- Data Registers
  signal INPUT_REG : std_logic_vector(31 downto 0);
  signal DRA_FA    : std_logic_vector(31 downto 0);
  signal DRB_FA    : std_logic_vector(31 downto 0);
  signal DRA_FB    : std_logic_vector(31 downto 0);
  signal DRB_FB    : std_logic_vector(31 downto 0);
  signal DRA_FC    : std_logic_vector(31 downto 0);
  signal DRB_FC    : std_logic_vector(31 downto 0);
  signal DRA_FD    : std_logic_vector(31 downto 0);
  signal DRB_FD    : std_logic_vector(31 downto 0);
  signal DRA_FE    : std_logic_vector(31 downto 0);
  signal DRB_FE    : std_logic_vector(31 downto 0);
  signal DRA_FF    : std_logic_vector(31 downto 0);
  signal DRB_FF    : std_logic_vector(31 downto 0);
  -- Next FIFO logic
  signal IDLE      : std_logic;
  signal IDLEv     : std_logic_vector(5 downto 0);
  signal CHANGE    : std_logic;
  signal READY     : std_logic_vector(5 downto 0);
  signal CURR_RDY  : std_logic_vector(5 downto 0);
  signal CURR_FIFO : std_logic_vector(5 downto 0);
  signal NEXT_FIFO : std_logic_vector(5 downto 0);
  signal CMUX_A    : std_logic_vector(5 downto 0);
  signal CMUX_B    : std_logic_vector(5 downto 0);
  signal CARRY_A   : std_logic_vector(5 downto 0);
  signal CARRY_B   : std_logic_vector(5 downto 0);
  signal RDY_A     : std_logic;
  signal RDY_B     : std_logic;
  signal IDLE_A    : std_logic;
  signal IDLE_B    : std_logic;
  signal RDY_FN0   : std_logic;
  signal RDY_FN1   : std_logic;
  signal RDY_FN2   : std_logic;
  signal RDY_FN3   : std_logic;
  signal RDY_FN4   : std_logic;
  signal RDY_FN5   : std_logic;
  signal RDY_FN6   : std_logic;
  signal RDY_FN7   : std_logic;
  signal RDY_FN8   : std_logic;
  -- Intermediate function terms
  signal S         : std_logic_vector(5 downto 0);
  signal T         : std_logic_vector(5 downto 0);
  signal U         : std_logic_vector(5 downto 0);
  signal V         : std_logic_vector(5 downto 0);
  signal W         : std_logic_vector(5 downto 0);
  signal X         : std_logic_vector(5 downto 0);
  signal Y         : std_logic_vector(5 downto 0);
  signal Z         : std_logic_vector(5 downto 0);
  signal V_REG     : std_logic_vector(5 downto 0);

  constant initv_2    : bit_vector := X"2";    -- LUT2 equation
  constant initv_4    : bit_vector := X"4";    -- LUT2 equation
  constant initv_6    : bit_vector := X"6";    -- LUT2 equation
  constant initv_8    : bit_vector := X"8";    -- LUT2 equation
  constant initv_b    : bit_vector := X"B";    -- LUT2 equation

  constant initv_01   : bit_vector := X"01";   -- LUT3 equation
  constant initv_02   : bit_vector := X"02";   -- LUT3 equation
  constant initv_a8   : bit_vector := X"A8";   -- LUT3 equation
  constant initv_ae   : bit_vector := X"AE";   -- LUT3 equation
  constant initv_e2   : bit_vector := X"E2";   -- LUT3 equation
  constant initv_fe   : bit_vector := X"FE";   -- LUT3 equation

  constant initv_0002 : bit_vector := X"0002"; -- LUT4 equation
  constant initv_0008 : bit_vector := X"0008"; -- LUT4 equation
  constant initv_000e : bit_vector := X"000E"; -- LUT4 equation
  constant initv_1115 : bit_vector := X"1115"; -- LUT4 equation
  constant initv_22f2 : bit_vector := X"22F2"; -- LUT4 equation
  constant initv_77f7 : bit_vector := X"77F7"; -- LUT4 equation
  constant initv_8000 : bit_vector := X"8000"; -- LUT4 equation
  constant initv_888a : bit_vector := X"888A"; -- LUT4 equation
  constant initv_e000 : bit_vector := X"E000"; -- LUT4 equation
  constant initv_f5e0 : bit_vector := X"F5E0"; -- LUT4 equation
  constant initv_feff : bit_vector := X"FEFF"; -- LUT4 equation
  constant initv_ff02 : bit_vector := X"FF02"; -- LUT4 equation
  constant initv_ff10 : bit_vector := X"FF10"; -- LUT4 equation
  constant initv_ffa8 : bit_vector := X"FFA8"; -- LUT4 equation
  constant initv_fffe : bit_vector := X"FFFE"; -- LUT4 equation

  attribute init : string;

  attribute init of iT0     : label is "2";
  attribute init of iT1     : label is "2";
  attribute init of iT2     : label is "2";
  attribute init of iT3     : label is "2";
  attribute init of iT4     : label is "2";
  attribute init of iT5     : label is "2";

  attribute init of iRDWB0  : label is "4";
  attribute init of iRDWB1  : label is "4";
  attribute init of iRDWB2  : label is "4";
  attribute init of iRDWB3  : label is "4";
  attribute init of iRDWB4  : label is "4";
  attribute init of iRDWB5  : label is "4";

  attribute init of iS0     : label is "8";
  attribute init of iS1     : label is "8";
  attribute init of iS2     : label is "8";
  attribute init of iS3     : label is "8";
  attribute init of iS4     : label is "8";
  attribute init of iS5     : label is "8";

  attribute init of iV0     : label is "8";
  attribute init of iV1     : label is "8";
  attribute init of iV2     : label is "8";
  attribute init of iV3     : label is "8";
  attribute init of iV4     : label is "8";
  attribute init of iV5     : label is "8";

  attribute init of iW0     : label is "8";
  attribute init of iW1     : label is "8";
  attribute init of iW2     : label is "8";
  attribute init of iW3     : label is "8";
  attribute init of iW4     : label is "8";
  attribute init of iW5     : label is "8";

  attribute init of iY0     : label is "8";
  attribute init of iY1     : label is "8";
  attribute init of iY2     : label is "8";
  attribute init of iY3     : label is "8";
  attribute init of iY4     : label is "8";
  attribute init of iY5     : label is "8";

  attribute init of iNEXT0  : label is "8";
  attribute init of iNEXT1  : label is "8";
  attribute init of iNEXT2  : label is "8";
  attribute init of iNEXT3  : label is "8";
  attribute init of iNEXT4  : label is "8";
  attribute init of iNEXT5  : label is "8";

  attribute init of iRDY_F3 : label is "B";
  attribute init of iRDY_F4 : label is "B";
  attribute init of iRDY_F5 : label is "B";
  attribute init of iRDY_F6 : label is "B";
  attribute init of iRDY_F7 : label is "B";
  attribute init of iRDY_F8 : label is "B";

  attribute init of iIDLE0  : label is "01";
  attribute init of iIDLE1  : label is "01";

  attribute init of iCRDY0  : label is "02";
  attribute init of iCRDY1  : label is "02";
  attribute init of iCRDY2  : label is "02";
  attribute init of iCRDY3  : label is "02";
  attribute init of iCRDY4  : label is "02";
  attribute init of iCRDY5  : label is "02";

  attribute init of iREADY0 : label is "A8";
  attribute init of iREADY1 : label is "A8";
  attribute init of iREADY2 : label is "A8";
  attribute init of iREADY3 : label is "A8";
  attribute init of iREADY4 : label is "A8";
  attribute init of iREADY5 : label is "A8";

  attribute init of iRDWA0  : label is "AE";
  attribute init of iRDWA1  : label is "AE";
  attribute init of iRDWA2  : label is "AE";
  attribute init of iRDWA3  : label is "AE";
  attribute init of iRDWA4  : label is "AE";
  attribute init of iRDWA5  : label is "AE";

  attribute init of iDRBCE0 : label is "E2";
  attribute init of iDRBCE1 : label is "E2";
  attribute init of iDRBCE2 : label is "E2";
  attribute init of iDRBCE3 : label is "E2";
  attribute init of iDRBCE4 : label is "E2";
  attribute init of iDRBCE5 : label is "E2";

  attribute init of iIR_A   : label is "FE";
  attribute init of iRDY0   : label is "FE";
  attribute init of iRDY1   : label is "FE";

  attribute init of iIDLE2  : label is "0002";

  attribute init of iX0     : label is "0008";
  attribute init of iX1     : label is "0008";
  attribute init of iX2     : label is "0008";
  attribute init of iX3     : label is "0008";
  attribute init of iX4     : label is "0008";
  attribute init of iX5     : label is "0008";

  attribute init of iU0     : label is "000E";
  attribute init of iU1     : label is "000E";
  attribute init of iU2     : label is "000E";
  attribute init of iU3     : label is "000E";
  attribute init of iU4     : label is "000E";
  attribute init of iU5     : label is "000E";

  attribute init of iCMA0   : label is "1115";
  attribute init of iCMA1   : label is "1115";
  attribute init of iCMA2   : label is "1115";
  attribute init of iCMA3   : label is "1115";
  attribute init of iCMA4   : label is "1115";
  attribute init of iCMA5   : label is "1115";

  attribute init of iCMB0   : label is "1115";
  attribute init of iCMB1   : label is "1115";
  attribute init of iCMB2   : label is "1115";
  attribute init of iCMB3   : label is "1115";
  attribute init of iCMB4   : label is "1115";

--attribute init of iDRAVC0 : label is "22F2";
--attribute init of iDRAVC1 : label is "22F2";
--attribute init of iDRAVC2 : label is "22F2";
--attribute init of iDRAVC3 : label is "22F2";
--attribute init of iDRAVC4 : label is "22F2";
--attribute init of iDRAVC5 : label is "22F2";

  attribute init of iIR_B   : label is "22F2";
  attribute init of iIR_C   : label is "22F2";
  attribute init of iIR_D   : label is "22F2";
  attribute init of iIR_E   : label is "22F2";
  attribute init of iIR_F   : label is "22F2";
  attribute init of iIR_G   : label is "22F2";

  attribute init of iDIVC   : label is "77F7";

  attribute init of iRENC0  : label is "8000";
  attribute init of iRENC1  : label is "8000";
  attribute init of iRENC2  : label is "8000";
  attribute init of iRENC3  : label is "8000";
  attribute init of iRENC4  : label is "8000";
  attribute init of iRENC5  : label is "8000";

  attribute init of iRD_OK0 : label is "888A";
  attribute init of iRD_OK1 : label is "888A";
  attribute init of iRD_OK2 : label is "888A";
  attribute init of iRD_OK3 : label is "888A";
  attribute init of iRD_OK4 : label is "888A";
  attribute init of iRD_OK5 : label is "888A";

  attribute init of iCHNG   : label is "E000";

  attribute init of iIRVC0  : label is "F5E0";
  attribute init of iIRVC1  : label is "F5E0";
  attribute init of iIRVC2  : label is "F5E0";
  attribute init of iIRVC3  : label is "F5E0";
  attribute init of iIRVC4  : label is "F5E0";
  attribute init of iIRVC5  : label is "F5E0";

  attribute init of iIRCE   : label is "FEFF";
  attribute init of iIRCEB  : label is "FEFF";
  attribute init of iIRCEC  : label is "FEFF";

  attribute init of iZ0     : label is "FF02";
  attribute init of iZ1     : label is "FF02";
  attribute init of iZ2     : label is "FF02";
  attribute init of iZ3     : label is "FF02";
  attribute init of iZ4     : label is "FF02";
  attribute init of iZ5     : label is "FF02";

  attribute init of iDRBVC0 : label is "FF10";
  attribute init of iDRBVC1 : label is "FF10";
  attribute init of iDRBVC2 : label is "FF10";
  attribute init of iDRBVC3 : label is "FF10";
  attribute init of iDRBVC4 : label is "FF10";
  attribute init of iDRBVC5 : label is "FF10";

  attribute init of iDVC0   : label is "FFA8";
  attribute init of iDVC1   : label is "FFA8";
  attribute init of iDVC2   : label is "FFA8";
  attribute init of iDVC3   : label is "FFA8";
  attribute init of iDVC4   : label is "FFA8";
  attribute init of iDVC5   : label is "FFA8";

  attribute init of iRDY_F0 : label is "FFFE";
  attribute init of iRDY_F1 : label is "FFFE";
  attribute init of iRDY_F2 : label is "FFFE";

begin

  GND <= '0';

  -- Instanciate these flip-flops to ensure they will always be IFDs
  iEF0 : FD port map (EF_REG(0),  D=>DIF_EF(0),  C=>CLK);  -- IOB
  iEF1 : FD port map (EF_REG(1),  D=>DIF_EF(1),  C=>CLK);  -- IOB
  iEF2 : FD port map (EF_REG(2),  D=>DIF_EF(2),  C=>CLK);  -- IOB
  iEF3 : FD port map (EF_REG(3),  D=>DIF_EF(3),  C=>CLK);  -- IOB
  iEF4 : FD port map (EF_REG(4),  D=>DIF_EF(4),  C=>CLK);  -- IOB
  iEF5 : FD port map (EF_REG(5),  D=>DIF_EF(5),  C=>CLK);  -- IOB

  -- Instanciate these flip-flops to ensure they will always be IFDs
  iAE0 : FD port map (AE_IFF(0),  D=>DIF_AE(0),  C=>CLK);  -- IOB
  iAE1 : FD port map (AE_IFF(1),  D=>DIF_AE(1),  C=>CLK);  -- IOB
  iAE2 : FD port map (AE_IFF(2),  D=>DIF_AE(2),  C=>CLK);  -- IOB
  iAE3 : FD port map (AE_IFF(3),  D=>DIF_AE(3),  C=>CLK);  -- IOB
  iAE4 : FD port map (AE_IFF(4),  D=>DIF_AE(4),  C=>CLK);  -- IOB
  iAE5 : FD port map (AE_IFF(5),  D=>DIF_AE(5),  C=>CLK);  -- IOB

  -- Delay the AE flag to work around known flag problem on the HEPC8
  iAE6  : FD port map (AE_DEL(0), D=>AE_IFF(0),  C=>CLK);
  iAE7  : FD port map (AE_DEL(1), D=>AE_IFF(1),  C=>CLK);
  iAE8  : FD port map (AE_DEL(2), D=>AE_IFF(2),  C=>CLK);
  iAE9  : FD port map (AE_DEL(3), D=>AE_IFF(3),  C=>CLK);
  iAE10 : FD port map (AE_DEL(4), D=>AE_IFF(4),  C=>CLK);
  iAE11 : FD port map (AE_DEL(5), D=>AE_IFF(5),  C=>CLK);

  -- The almost empty flag is only taken as asserted when the input
  -- register signal AND the delayed signal are both high.
  AE_REG <= AE_IFF AND AE_DEL;

  INFIFO_SINGLE <= EF_REG OR IRV OR DRBV;

  INFIFO_BURST  <= EF_REG AND AE_IFF AND AE_DEL;

  -- Instanciate these flip-flops to ensure they will always be IFDs
  iDI0  : FDCE port map (INPUT_REG(0),  D=>DI(0),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI1  : FDCE port map (INPUT_REG(1),  D=>DI(1),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI2  : FDCE port map (INPUT_REG(2),  D=>DI(2),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI3  : FDCE port map (INPUT_REG(3),  D=>DI(3),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI4  : FDCE port map (INPUT_REG(4),  D=>DI(4),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI5  : FDCE port map (INPUT_REG(5),  D=>DI(5),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI6  : FDCE port map (INPUT_REG(6),  D=>DI(6),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI7  : FDCE port map (INPUT_REG(7),  D=>DI(7),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB

  iDI8  : FDCE port map (INPUT_REG(8),  D=>DI(8),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI9  : FDCE port map (INPUT_REG(9),  D=>DI(9),  C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI10 : FDCE port map (INPUT_REG(10), D=>DI(10), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI11 : FDCE port map (INPUT_REG(11), D=>DI(11), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI12 : FDCE port map (INPUT_REG(12), D=>DI(12), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI13 : FDCE port map (INPUT_REG(13), D=>DI(13), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI14 : FDCE port map (INPUT_REG(14), D=>DI(14), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB
  iDI15 : FDCE port map (INPUT_REG(15), D=>DI(15), C=>CLK, CE=>IR_CE_B, CLR=>GND);  -- IOB

  iDI16 : FDCE port map (INPUT_REG(16), D=>DI(16), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI17 : FDCE port map (INPUT_REG(17), D=>DI(17), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI18 : FDCE port map (INPUT_REG(18), D=>DI(18), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI19 : FDCE port map (INPUT_REG(19), D=>DI(19), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI20 : FDCE port map (INPUT_REG(20), D=>DI(20), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI21 : FDCE port map (INPUT_REG(21), D=>DI(21), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI22 : FDCE port map (INPUT_REG(22), D=>DI(22), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI23 : FDCE port map (INPUT_REG(23), D=>DI(23), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB

  iDI24 : FDCE port map (INPUT_REG(24), D=>DI(24), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI25 : FDCE port map (INPUT_REG(25), D=>DI(25), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI26 : FDCE port map (INPUT_REG(26), D=>DI(26), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI27 : FDCE port map (INPUT_REG(27), D=>DI(27), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI28 : FDCE port map (INPUT_REG(28), D=>DI(28), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI29 : FDCE port map (INPUT_REG(29), D=>DI(29), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI30 : FDCE port map (INPUT_REG(30), D=>DI(30), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB
  iDI31 : FDCE port map (INPUT_REG(31), D=>DI(31), C=>CLK, CE=>IR_CE_C, CLR=>GND);  -- IOB

  -- Read Enable logic
  -- =================
  -- DIF_REN - OBUF_F_8 (instanciation in the top level)
  -- DIF_OEN - OBUF_F_8 (instanciation in the top level)

  -- Instanciate these flip-flops to ensure they will always be OFDs
  iRE0 : FDC port map (DIF_REN(0), D=>RENc(0), C=>CLK, CLR=>RST);  -- IOB
  iRE1 : FDC port map (DIF_REN(1), D=>RENc(1), C=>CLK, CLR=>RST);  -- IOB
  iRE2 : FDC port map (DIF_REN(2), D=>RENc(2), C=>CLK, CLR=>RST);  -- IOB
  iRE3 : FDC port map (DIF_REN(3), D=>RENc(3), C=>CLK, CLR=>RST);  -- IOB
  iRE4 : FDC port map (DIF_REN(4), D=>RENc(4), C=>CLK, CLR=>RST);  -- IOB
  iRE5 : FDC port map (DIF_REN(5), D=>RENc(5), C=>CLK, CLR=>RST);  -- IOB

  iREN0 : FDC port map (REN(0), D=>RENc(0), C=>CLK, CLR=>RST);
  iREN1 : FDC port map (REN(1), D=>RENc(1), C=>CLK, CLR=>RST);
  iREN2 : FDC port map (REN(2), D=>RENc(2), C=>CLK, CLR=>RST);
  iREN3 : FDC port map (REN(3), D=>RENc(3), C=>CLK, CLR=>RST);
  iREN4 : FDC port map (REN(4), D=>RENc(4), C=>CLK, CLR=>RST);
  iREN5 : FDC port map (REN(5), D=>RENc(5), C=>CLK, CLR=>RST);

--Z(0) <= REN(0) OR ((NOT REN(1)) AND (NOT REN(2)) AND IDLE_B);
--Z(1) <= REN(1) OR ((NOT REN(0)) AND (NOT REN(2)) AND IDLE_B);
--Z(2) <= REN(2) OR ((NOT REN(0)) AND (NOT REN(1)) AND IDLE_B);
--Z(3) <= REN(3) OR ((NOT REN(4)) AND (NOT REN(5)) AND IDLE_A);
--Z(4) <= REN(4) OR ((NOT REN(3)) AND (NOT REN(5)) AND IDLE_A);
--Z(5) <= REN(5) OR ((NOT REN(3)) AND (NOT REN(4)) AND IDLE_A);

  iZ0 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_B,
      i1 => REN(2),
      i2 => REN(1),
      i3 => REN(0),
      o  => Z(0) );

  iZ1 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_B,
      i1 => REN(2),
      i2 => REN(0),
      i3 => REN(1),
      o  => Z(1) );

  iZ2 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_B,
      i1 => REN(1),
      i2 => REN(0),
      i3 => REN(2),
      o  => Z(2) );

  iZ3 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_A,
      i1 => REN(5),
      i2 => REN(4),
      i3 => REN(3),
      o  => Z(3) );

  iZ4 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_A,
      i1 => REN(5),
      i2 => REN(3),
      i3 => REN(4),
      o  => Z(4) );

  iZ5 : lut4
    --pragma translate_off
    generic map (init => initv_ff02)
    --pragma translate_on
    port map (
      i0 => IDLE_A,
      i1 => REN(4),
      i2 => REN(3),
      i3 => REN(5),
      o  => Z(5) );

--RENc <= (RD_OK AND CARRY_B AND READY AND Z);

  iRENC0 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(0),
      i1 => READY(0),
      i2 => CARRY_B(0),
      i3 => RD_OK(0),
      o  => RENc(0) );

  iRENC1 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(1),
      i1 => READY(1),
      i2 => CARRY_B(1),
      i3 => RD_OK(1),
      o  => RENc(1) );

  iRENC2 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(2),
      i1 => READY(2),
      i2 => CARRY_B(2),
      i3 => RD_OK(2),
      o  => RENc(2) );

  iRENC3 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(3),
      i1 => READY(3),
      i2 => CARRY_B(3),
      i3 => RD_OK(3),
      o  => RENc(3) );

  iRENC4 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(4),
      i1 => READY(4),
      i2 => CARRY_B(4),
      i3 => RD_OK(4),
      o  => RENc(4) );

  iRENC5 : lut4
    --pragma translate_off
    generic map (init => initv_8000)
    --pragma translate_on
    port map (
      i0 => Z(5),
      i1 => READY(5),
      i2 => CARRY_B(5),
      i3 => RD_OK(5),
      o  => RENc(5) );

  DIF_OEN <= NOT CURR_FIFO;

--RD_OK <= (EF_REG AND (NOT (RD_WA OR RD_WB))) OR (EF_REG AND AE_REG);

  iRD_OK0 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(0),
      i1 => AE_REG(0),
      i2 => RD_WA(0),
      i3 => RD_WB(0),
      o  => RD_OK(0) );

  iRD_OK1 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(1),
      i1 => AE_REG(1),
      i2 => RD_WA(1),
      i3 => RD_WB(1),
      o  => RD_OK(1) );

  iRD_OK2 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(2),
      i1 => AE_REG(2),
      i2 => RD_WA(2),
      i3 => RD_WB(2),
      o  => RD_OK(2) );

  iRD_OK3 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(3),
      i1 => AE_REG(3),
      i2 => RD_WA(3),
      i3 => RD_WB(3),
      o  => RD_OK(3) );

  iRD_OK4 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(4),
      i1 => AE_REG(4),
      i2 => RD_WA(4),
      i3 => RD_WB(4),
      o  => RD_OK(4) );

  iRD_OK5 : lut4
    --pragma translate_off
    generic map (init => initv_888a)
    --pragma translate_on
    port map (
      i0 => EF_REG(5),
      i1 => AE_REG(5),
      i2 => RD_WA(5),
      i3 => RD_WB(5),
      o  => RD_OK(5) );

  iRD_WA0 : FD port map (RD_WA(0), D=>RD_WAc(0), C=>CLK);
  iRD_WA1 : FD port map (RD_WA(1), D=>RD_WAc(1), C=>CLK);
  iRD_WA2 : FD port map (RD_WA(2), D=>RD_WAc(2), C=>CLK);
  iRD_WA3 : FD port map (RD_WA(3), D=>RD_WAc(3), C=>CLK);
  iRD_WA4 : FD port map (RD_WA(4), D=>RD_WAc(4), C=>CLK);
  iRD_WA5 : FD port map (RD_WA(5), D=>RD_WAc(5), C=>CLK);

  iRD_WB0 : FD port map (RD_WB(0), D=>RD_WBc(0), C=>CLK);
  iRD_WB1 : FD port map (RD_WB(1), D=>RD_WBc(1), C=>CLK);
  iRD_WB2 : FD port map (RD_WB(2), D=>RD_WBc(2), C=>CLK);
  iRD_WB3 : FD port map (RD_WB(3), D=>RD_WBc(3), C=>CLK);
  iRD_WB4 : FD port map (RD_WB(4), D=>RD_WBc(4), C=>CLK);
  iRD_WB5 : FD port map (RD_WB(5), D=>RD_WBc(5), C=>CLK);

--RD_WAc <= RENc OR (RD_WA AND (NOT RD_WB));

  iRDWA0 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(0),
      i1 => RD_WA(0),
      i2 => RD_WB(0),
      o  => RD_WAc(0) );

  iRDWA1 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(1),
      i1 => RD_WA(1),
      i2 => RD_WB(1),
      o  => RD_WAc(1) );

  iRDWA2 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(2),
      i1 => RD_WA(2),
      i2 => RD_WB(2),
      o  => RD_WAc(2) );

  iRDWA3 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(3),
      i1 => RD_WA(3),
      i2 => RD_WB(3),
      o  => RD_WAc(3) );

  iRDWA4 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(4),
      i1 => RD_WA(4),
      i2 => RD_WB(4),
      o  => RD_WAc(4) );

  iRDWA5 : lut3
    --pragma translate_off
    generic map (init => initv_ae)
    --pragma translate_on
    port map (
      i0 => RENc(5),
      i1 => RD_WA(5),
      i2 => RD_WB(5),
      o  => RD_WAc(5) );

--RD_WBc <= RD_WA AND (NOT RENc);

  iRDWB0 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(0),
      i1 => RD_WA(0),
      o  => RD_WBc(0) );

  iRDWB1 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(1),
      i1 => RD_WA(1),
      o  => RD_WBc(1) );

  iRDWB2 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(2),
      i1 => RD_WA(2),
      o  => RD_WBc(2) );

  iRDWB3 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(3),
      i1 => RD_WA(3),
      o  => RD_WBc(3) );

  iRDWB4 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(4),
      i1 => RD_WA(4),
      o  => RD_WBc(4) );

  iRDWB5 : lut2
    --pragma translate_off
    generic map (init => initv_4)
    --pragma translate_on
    port map (
      i0 => RENc(5),
      i1 => RD_WA(5),
      o  => RD_WBc(5) );

  -- Data Valid logic
  -- ================

--DIVc <= (NOT IDLE_A) OR (NOT IDLE_B) OR (DIV AND (NOT IR_CE));

  iDIVC : lut4
    --pragma translate_off
    generic map (init => initv_77f7)
    --pragma translate_on
    port map (
      i0 => IDLE_A,
      i1 => IDLE_B,
      i2 => DIV,
      i3 => IR_CE,
      o  => DIVc );

  DIVv <= DIV & DIV & DIV & DIV & DIV & DIV;

--Y <= DIVv AND CURR_FIFO;

  iY0 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => DIV,
      o  => Y(0) );

  iY1 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => DIV,
      o  => Y(1) );

  iY2 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => DIV,
      o  => Y(2) );

  iY3 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => DIV,
      o  => Y(3) );

  iY4 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => DIV,
      o  => Y(4) );

  iY5 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(5),
      i1 => DIV,
      o  => Y(5) );

--T(0) <= (NOT INFIFO_READ_REQ(0)) AND CURR_FIFO(0);
--T(1) <= (NOT INFIFO_READ_REQ(1)) AND CURR_FIFO(1);
--T(2) <= (NOT INFIFO_READ_REQ(2)) AND CURR_FIFO(2);
--T(3) <= (NOT INFIFO_READ_REQ(3)) AND CURR_FIFO(3);
--T(4) <= (NOT INFIFO_READ_REQ(4)) AND CURR_FIFO(4);
--T(5) <= (NOT INFIFO_READ_REQ(5)) AND CURR_FIFO(5);
  
  iT0 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => INFIFO_READ_REQ(0),
      o  => T(0) );

  iT1 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => INFIFO_READ_REQ(1),
      o  => T(1) );

  iT2 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => INFIFO_READ_REQ(2),
      o  => T(2) );

  iT3 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => INFIFO_READ_REQ(3),
      o  => T(3) );

  iT4 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => INFIFO_READ_REQ(4),
      o  => T(4) );

  iT5 : lut2
    --pragma translate_off
    generic map (init => initv_2)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(5),
      i1 => INFIFO_READ_REQ(5),
      o  => T(5) );

--X(0) <= IRV(0) AND (NOT DVALID(0)) AND T(0) AND (NOT READY(1));
--X(1) <= IRV(1) AND (NOT DVALID(1)) AND T(1) AND (NOT READY(0));
--X(2) <= IRV(2) AND (NOT DVALID(2)) AND T(2) AND (NOT READY(3));
--X(3) <= IRV(3) AND (NOT DVALID(3)) AND T(3) AND (NOT READY(2));
--X(4) <= IRV(4) AND (NOT DVALID(4)) AND T(4) AND (NOT READY(5));
--X(5) <= IRV(5) AND (NOT DVALID(5)) AND T(5) AND (NOT READY(4));

  iX0 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(0),
      i1 => T(0),
      i2 => READY(1),
      i3 => DVALID(0),
      o  => X(0) );

  iX1 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(1),
      i1 => T(1),
      i2 => READY(0),
      i3 => DVALID(1),
      o  => X(1) );

  iX2 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(2),
      i1 => T(2),
      i2 => READY(3),
      i3 => DVALID(2),
      o  => X(2) );

  iX3 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(3),
      i1 => T(3),
      i2 => READY(2),
      i3 => DVALID(3),
      o  => X(3) );

  iX4 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(4),
      i1 => T(4),
      i2 => READY(5),
      i3 => DVALID(4),
      o  => X(4) );

  iX5 : lut4
    --pragma translate_off
    generic map (init => initv_0008)
    --pragma translate_on
    port map (
      i0 => IRV(5),
      i1 => T(5),
      i2 => READY(4),
      i3 => DVALID(5),
      o  => X(5) );

--IRVc(0) <= (Y AND RDY_FN3) OR (Y AND RDY_FN0) OR (X AND (NOT RDY_FN0));
--IRVc(1) <= (Y AND RDY_FN4) OR (Y AND RDY_FN0) OR (X AND (NOT RDY_FN0));
--IRVc(2) <= (Y AND RDY_FN5) OR (Y AND RDY_FN1) OR (X AND (NOT RDY_FN1));
--IRVc(3) <= (Y AND RDY_FN6) OR (Y AND RDY_FN1) OR (X AND (NOT RDY_FN1));
--IRVc(4) <= (Y AND RDY_FN7) OR (Y AND RDY_FN2) OR (X AND (NOT RDY_FN2));
--IRVc(5) <= (Y AND RDY_FN8) OR (Y AND RDY_FN2) OR (X AND (NOT RDY_FN2));

  iIRVC0 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN0,
      i1 => RDY_FN3,
      i2 => Y(0),
      i3 => X(0),
      o  => IRVc(0) );

  iIRVC1 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN0,
      i1 => RDY_FN4,
      i2 => Y(1),
      i3 => X(1),
      o  => IRVc(1) );

  iIRVC2 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN1,
      i1 => RDY_FN5,
      i2 => Y(2),
      i3 => X(2),
      o  => IRVc(2) );

   iIRVC3 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN1,
      i1 => RDY_FN6,
      i2 => Y(3),
      i3 => X(3),
      o  => IRVc(3) );

  iIRVC4 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN2,
      i1 => RDY_FN7,
      i2 => Y(4),
      i3 => X(4),
      o  => IRVc(4) );

  iIRVC5 : lut4
    --pragma translate_off
    generic map (init => initv_f5e0)
    --pragma translate_on
    port map (
      i0 => RDY_FN2,
      i1 => RDY_FN8,
      i2 => Y(5),
      i3 => X(5),
      o  => IRVc(5) );

--S <= DRAV AND DRBV;

  iS0 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(0),
      i1 => DRBV(0),
      o  => S(0) );

  iS1 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(1),
      i1 => DRBV(1),
      o  => S(1) );

  iS2 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(2),
      i1 => DRBV(2),
      o  => S(2) );

  iS3 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(3),
      i1 => DRBV(3),
      o  => S(3) );

  iS4 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(4),
      i1 => DRBV(4),
      o  => S(4) );

  iS5 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => DRAV(5),
      i1 => DRBV(5),
      o  => S(5) );

  DRAVc <= (IRV AND (NOT CURR_RDY)) OR (S AND (NOT V)) OR (IRV AND DRBV AND V);

--iDRAVC0 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(0),
--    i1 => CURR_RDY(0),
--    i2 => S(0),
--    i3 => V(0),
--    o  => DRAVc(0) );

--iDRAVC1 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(1),
--    i1 => CURR_RDY(1),
--    i2 => S(1),
--    i3 => V(1),
--    o  => DRAVc(1) );

--iDRAVC2 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(2),
--    i1 => CURR_RDY(2),
--    i2 => S(2),
--    i3 => V(2),
--    o  => DRAVc(2) );

--iDRAVC3 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(3),
--    i1 => CURR_RDY(3),
--    i2 => S(3),
--    i3 => V(3),
--    o  => DRAVc(3) );

--iDRAVC4 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(4),
--    i1 => CURR_RDY(4),
--    i2 => S(4),
--    i3 => V(4),
--    o  => DRAVc(4) );

--iDRAVC5 : lut4
--  --pragma translate_off
--  generic map (init => initv_22f2)
--  --pragma translate_on
--  port map (
--    i0 => IRV(5),
--    i1 => CURR_RDY(5),
--    i2 => S(5),
--    i3 => V(5),
--    o  => DRAVc(5) );

--DRBVc <= DRAV OR (DRBV AND (NOT V) AND (NOT W));

  iDRBVC0 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(0),
      i1 => V(0),
      i2 => DRBV(0),
      i3 => DRAV(0),
      o  => DRBVc(0) );

  iDRBVC1 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(1),
      i1 => V(1),
      i2 => DRBV(1),
      i3 => DRAV(1),
      o  => DRBVc(1) );

  iDRBVC2 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(2),
      i1 => V(2),
      i2 => DRBV(2),
      i3 => DRAV(2),
      o  => DRBVc(2) );

  iDRBVC3 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(3),
      i1 => V(3),
      i2 => DRBV(3),
      i3 => DRAV(3),
      o  => DRBVc(3) );

  iDRBVC4 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(4),
      i1 => V(4),
      i2 => DRBV(4),
      i3 => DRAV(4),
      o  => DRBVc(4) );

  iDRBVC5 : lut4
    --pragma translate_off
    generic map (init => initv_ff10)
    --pragma translate_on
    port map (
      i0 => W(5),
      i1 => V(5),
      i2 => DRBV(5),
      i3 => DRAV(5),
      o  => DRBVc(5) );

  iDIV : FDC port map (DIV, D=>DIVc, C=>CLK, CLR=>RST);

  iIRV0  : FDC port map (IRV(0),  D=>IRVc(0),  C=>CLK, CLR=>RST);
  iIRV1  : FDC port map (IRV(1),  D=>IRVc(1),  C=>CLK, CLR=>RST);
  iIRV2  : FDC port map (IRV(2),  D=>IRVc(2),  C=>CLK, CLR=>RST);
  iIRV3  : FDC port map (IRV(3),  D=>IRVc(3),  C=>CLK, CLR=>RST);
  iIRV4  : FDC port map (IRV(4),  D=>IRVc(4),  C=>CLK, CLR=>RST);
  iIRV5  : FDC port map (IRV(5),  D=>IRVc(5),  C=>CLK, CLR=>RST);

  iDRAV0 : FDC port map (DRAV(0), D=>DRAVc(0), C=>CLK, CLR=>RST);
  iDRAV1 : FDC port map (DRAV(1), D=>DRAVc(1), C=>CLK, CLR=>RST);
  iDRAV2 : FDC port map (DRAV(2), D=>DRAVc(2), C=>CLK, CLR=>RST);
  iDRAV3 : FDC port map (DRAV(3), D=>DRAVc(3), C=>CLK, CLR=>RST);
  iDRAV4 : FDC port map (DRAV(4), D=>DRAVc(4), C=>CLK, CLR=>RST);
  iDRAV5 : FDC port map (DRAV(5), D=>DRAVc(5), C=>CLK, CLR=>RST);

  iDRBV0 : FDC port map (DRBV(0), D=>DRBVc(0), C=>CLK, CLR=>RST);
  iDRBV1 : FDC port map (DRBV(1), D=>DRBVc(1), C=>CLK, CLR=>RST);
  iDRBV2 : FDC port map (DRBV(2), D=>DRBVc(2), C=>CLK, CLR=>RST);
  iDRBV3 : FDC port map (DRBV(3), D=>DRBVc(3), C=>CLK, CLR=>RST);
  iDRBV4 : FDC port map (DRBV(4), D=>DRBVc(4), C=>CLK, CLR=>RST);
  iDRBV5 : FDC port map (DRBV(5), D=>DRBVc(5), C=>CLK, CLR=>RST);

  iSEL0  : FDC port map (SEL(0),  D=>DRBV(0),  C=>CLK, CLR=>RST);
  iSEL1  : FDC port map (SEL(1),  D=>DRBV(1),  C=>CLK, CLR=>RST);
  iSEL2  : FDC port map (SEL(2),  D=>DRBV(2),  C=>CLK, CLR=>RST);
  iSEL3  : FDC port map (SEL(3),  D=>DRBV(3),  C=>CLK, CLR=>RST);
  iSEL4  : FDC port map (SEL(4),  D=>DRBV(4),  C=>CLK, CLR=>RST);
  iSEL5  : FDC port map (SEL(5),  D=>DRBV(5),  C=>CLK, CLR=>RST);

--U(0) <= (NOT RDY_FN3) AND (NOT RDY_FN0) AND (IRV(0) OR Y(0));
--U(1) <= (NOT RDY_FN4) AND (NOT RDY_FN0) AND (IRV(1) OR Y(1));
--U(2) <= (NOT RDY_FN5) AND (NOT RDY_FN1) AND (IRV(2) OR Y(2));
--U(3) <= (NOT RDY_FN6) AND (NOT RDY_FN1) AND (IRV(3) OR Y(3));
--U(4) <= (NOT RDY_FN7) AND (NOT RDY_FN2) AND (IRV(4) OR Y(4));
--U(5) <= (NOT RDY_FN8) AND (NOT RDY_FN2) AND (IRV(5) OR Y(5));

  iU0 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(0),
      i1 => IRV(0),
      i2 => RDY_FN0,
      i3 => RDY_FN3,
      o  => U(0) );

  iU1 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(1),
      i1 => IRV(1),
      i2 => RDY_FN0,
      i3 => RDY_FN4,
      o  => U(1) );

  iU2 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(2),
      i1 => IRV(2),
      i2 => RDY_FN1,
      i3 => RDY_FN5,
      o  => U(2) );

  iU3 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(3),
      i1 => IRV(3),
      i2 => RDY_FN1,
      i3 => RDY_FN6,
      o  => U(3) );

  iU4 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(4),
      i1 => IRV(4),
      i2 => RDY_FN2,
      i3 => RDY_FN7,
      o  => U(4) );

  iU5 : lut4
    --pragma translate_off
    generic map (init => initv_000e)
    --pragma translate_on
    port map (
      i0 => Y(5),
      i1 => IRV(5),
      i2 => RDY_FN2,
      i3 => RDY_FN8,
      o  => U(5) );

--V <= NEXT_FIFO AND IDLEv;

  iV0 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(0),
      i1 => IDLE,
      o  => V(0) );

  iV1 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(1),
      i1 => IDLE,
      o  => V(1) );

  iV2 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(2),
      i1 => IDLE,
      o  => V(2) );

  iV3 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(3),
      i1 => IDLE,
      o  => V(3) );

  iV4 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(4),
      i1 => IDLE,
      o  => V(4) );

  iV5 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => NEXT_FIFO(5),
      i1 => IDLE,
      o  => V(5) );

--W <= CURR_FIFO AND INFIFO_READ_REQ;

  iW0 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => INFIFO_READ_REQ(0),
      o  => W(0) );

  iW1 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => INFIFO_READ_REQ(1),
      o  => W(1) );

  iW2 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => INFIFO_READ_REQ(2),
      o  => W(2) );

  iW3 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => INFIFO_READ_REQ(3),
      o  => W(3) );

  iW4 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => INFIFO_READ_REQ(4),
      o  => W(4) );

  iW5 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(5),
      i1 => INFIFO_READ_REQ(5),
      o  => W(5) );

--DVALIDc <= U OR (DRBV AND V) OR (DRBV AND W);

  iDVC0 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(0),
      i1 => W(0),
      i2 => V(0),
      i3 => U(0),
      o  => DVALIDc(0) );

  iDVC1 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(1),
      i1 => W(1),
      i2 => V(1),
      i3 => U(1),
      o  => DVALIDc(1) );

  iDVC2 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(2),
      i1 => W(2),
      i2 => V(2),
      i3 => U(2),
      o  => DVALIDc(2) );

  iDVC3 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(3),
      i1 => W(3),
      i2 => V(3),
      i3 => U(3),
      o  => DVALIDc(3) );

  iDVC4 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(4),
      i1 => W(4),
      i2 => V(4),
      i3 => U(4),
      o  => DVALIDc(4) );

  iDVC5 : lut4
    --pragma translate_off
    generic map (init => initv_ffa8)
    --pragma translate_on
    port map (
      i0 => DRBV(5),
      i1 => W(5),
      i2 => V(5),
      i3 => U(5),
      o  => DVALIDc(5) );

  iDVALID0 : FDC port map (DVALID(0), D=>DVALIDc(0), C=>CLK, CLR=>RST);
  iDVALID1 : FDC port map (DVALID(1), D=>DVALIDc(1), C=>CLK, CLR=>RST);
  iDVALID2 : FDC port map (DVALID(2), D=>DVALIDc(2), C=>CLK, CLR=>RST);
  iDVALID3 : FDC port map (DVALID(3), D=>DVALIDc(3), C=>CLK, CLR=>RST);
  iDVALID4 : FDC port map (DVALID(4), D=>DVALIDc(4), C=>CLK, CLR=>RST);
  iDVALID5 : FDC port map (DVALID(5), D=>DVALIDc(5), C=>CLK, CLR=>RST);

  INFIFO_DVALID <= DVALID;

  -- Register Enable logic
  -- =====================

--IR_E <= (IRV(0) AND (NOT DVALID(0))) OR
--        (IRV(1) AND (NOT DVALID(1)));

  iIR_E : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => IRV(1),
      i1 => DVALID(1),
      i2 => IRV(0),
      i3 => DVALID(0),
      o  => IR_E );

--IR_F <= (IRV(2) AND (NOT DVALID(2))) OR
--        (IRV(3) AND (NOT DVALID(3)));

  iIR_F : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => IRV(3),
      i1 => DVALID(3),
      i2 => IRV(2),
      i3 => DVALID(2),
      o  => IR_F );

--IR_G <= (IRV(4) AND (NOT DVALID(4))) OR
--        (IRV(5) AND (NOT DVALID(5)));

  iIR_G : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => IRV(5),
      i1 => DVALID(5),
      i2 => IRV(4),
      i3 => DVALID(4),
      o  => IR_G );

--IR_B <= ((NOT CURR_FIFO(0)) AND READY(0)) OR
--        ((NOT CURR_FIFO(1)) AND READY(1));

  iIR_B : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => READY(1),
      i1 => CURR_FIFO(1),
      i2 => READY(0),
      i3 => CURR_FIFO(0),
      o  => IR_B );

--IR_C <= ((NOT CURR_FIFO(2)) AND READY(2)) OR
--        ((NOT CURR_FIFO(3)) AND READY(3));

  iIR_C : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => READY(3),
      i1 => CURR_FIFO(3),
      i2 => READY(2),
      i3 => CURR_FIFO(2),
      o  => IR_C );

--IR_D <= ((NOT CURR_FIFO(4)) AND READY(4)) OR
--        ((NOT CURR_FIFO(5)) AND READY(5));

  iIR_D : lut4
    --pragma translate_off
    generic map (init => initv_22f2)
    --pragma translate_on
    port map (
      i0 => READY(5),
      i1 => CURR_FIFO(5),
      i2 => READY(4),
      i3 => CURR_FIFO(4),
      o  => IR_D );

--IR_A <= IR_E OR IR_F OR IR_G;

  iIR_A : lut3
    --pragma translate_off
    generic map (init => initv_fe)
    --pragma translate_on
    port map (
      i0 => IR_G,
      i1 => IR_F,
      i2 => IR_E,
      o  => IR_A );

--IR_CE <= NOT (IR_A AND (NOT (IR_B OR IR_C OR IR_D)));

  iIRCE : lut4
    --pragma translate_off
    generic map (init => initv_feff)
    --pragma translate_on
    port map (
      i0 => IR_D,
      i1 => IR_C,
      i2 => IR_B,
      i3 => IR_A,
      o  => IR_CE );

  IR_CEv <= (IR_CE & IR_CE & IR_CE & IR_CE & IR_CE & IR_CE);

  iIRCEB : lut4
    --pragma translate_off
    generic map (init => initv_feff)
    --pragma translate_on
    port map (
      i0 => IR_D,
      i1 => IR_C,
      i2 => IR_B,
      i3 => IR_A,
      o  => IR_CE_B );

  iIRCEC : lut4
    --pragma translate_off
    generic map (init => initv_feff)
    --pragma translate_on
    port map (
      i0 => IR_D,
      i1 => IR_C,
      i2 => IR_B,
      i3 => IR_A,
      o  => IR_CE_C );

  DRA_CE <= IRV;

  process(RST, CLK)
  begin
    if RST='1' then
      V_REG <= (others=>'0');
    elsif rising_edge(CLK) then
      V_REG <= V;
    end if;
  end process;

--DRB_CE <= (DRAV AND (NOT DRBV)) OR (DRBV AND V_REG);

  iDRBCE0 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(0),
      i1 => DRBV(0),
      i2 => V_REG(0),
      o  => DRB_CE(0) );

  iDRBCE1 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(1),
      i1 => DRBV(1),
      i2 => V_REG(1),
      o  => DRB_CE(1) );

  iDRBCE2 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(2),
      i1 => DRBV(2),
      i2 => V_REG(2),
      o  => DRB_CE(2) );

  iDRBCE3 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(3),
      i1 => DRBV(3),
      i2 => V_REG(3),
      o  => DRB_CE(3) );

  iDRBCE4 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(4),
      i1 => DRBV(4),
      i2 => V_REG(4),
      o  => DRB_CE(4) );

  iDRBCE5 : lut3
    --pragma translate_off
    generic map (init => initv_e2)
    --pragma translate_on
    port map (
      i0 => DRAV(5),
      i1 => DRBV(5),
      i2 => V_REG(5),
      o  => DRB_CE(5) );

  -- Data Registers
  -- ==============

  process(RST, CLK)
  begin
    if RST='1' then
      DRA_FA <= (others=>'0');
      DRA_FB <= (others=>'0');
      DRA_FC <= (others=>'0');
      DRA_FD <= (others=>'0');
      DRA_FE <= (others=>'0');
      DRA_FF <= (others=>'0');
    elsif rising_edge(CLK) then
      if DRA_CE(0)='1' then
        DRA_FA <= INPUT_REG;
      end if;
      if DRA_CE(1)='1' then
        DRA_FB <= INPUT_REG;
      end if;
      if DRA_CE(2)='1' then
        DRA_FC <= INPUT_REG;
      end if;
      if DRA_CE(3)='1' then
        DRA_FD <= INPUT_REG;
      end if;
      if DRA_CE(4)='1' then
        DRA_FE <= INPUT_REG;
      end if;
      if DRA_CE(5)='1' then
        DRA_FF <= INPUT_REG;
      end if;
    end if;
  end process;

  process(RST, CLK)
  begin
    if RST='1' then
      DRB_FA <= (others=>'0');
      DRB_FB <= (others=>'0');
      DRB_FC <= (others=>'0');
      DRB_FD <= (others=>'0');
      DRB_FE <= (others=>'0');
      DRB_FF <= (others=>'0');
    elsif rising_edge(CLK) then
      if DRB_CE(0)='1' then
        DRB_FA <= DRA_FA;
      end if;
      if DRB_CE(1)='1' then
        DRB_FB <= DRA_FB;
      end if;
      if DRB_CE(2)='1' then
        DRB_FC <= DRA_FC;
      end if;
      if DRB_CE(3)='1' then
        DRB_FD <= DRA_FD;
      end if;
      if DRB_CE(4)='1' then
        DRB_FE <= DRA_FE;
      end if;
      if DRB_CE(5)='1' then
        DRB_FF <= DRA_FF;
      end if;
    end if;
  end process;

  INFIFO0_D <= INPUT_REG when SEL(0)='0' else DRB_FA;
  INFIFO1_D <= INPUT_REG when SEL(1)='0' else DRB_FB;
  INFIFO2_D <= INPUT_REG when SEL(2)='0' else DRB_FC;
  INFIFO3_D <= INPUT_REG when SEL(3)='0' else DRB_FD;
  INFIFO4_D <= INPUT_REG when SEL(4)='0' else DRB_FE;
  INFIFO5_D <= INPUT_REG when SEL(5)='0' else DRB_FF;
 
  -- Next FIFO logic
  -- ===============

  iRDY0 : lut3
    --pragma translate_off
    generic map (init => initv_fe)
    --pragma translate_on
    port map (
      i0 => READY(0),
      i1 => READY(1),
      i2 => READY(2),
      o  => RDY_A );

  iRDY1 : lut3
    --pragma translate_off
    generic map (init => initv_fe)
    --pragma translate_on
    port map (
      i0 => READY(3),
      i1 => READY(4),
      i2 => READY(5),
      o  => RDY_B );

--CHANGE  <= (IDLE_A AND IDLE_B) AND (RDY_A OR RDY_B);

  iCHNG : lut4
    --pragma translate_off
    generic map (init => initv_e000)
    --pragma translate_on
    port map (
      i0 => RDY_A,
      i1 => RDY_B,
      i2 => IDLE_A,
      i3 => IDLE_B,
      o  => CHANGE );

--IDLE  <= (NOT REN(0)) AND (NOT REN(1)) AND (NOT REN(2)) AND
--         (NOT REN(3)) AND (NOT REN(4)) AND (NOT REN(5));

--IDLE_A <= (NOT REN(0)) AND (NOT REN(1)) AND (NOT REN(2));
--IDLE_B <= (NOT REN(3)) AND (NOT REN(4)) AND (NOT REN(5));

  iIDLE0 : lut3
    --pragma translate_off
    generic map (init => initv_01)
    --pragma translate_on
    port map (
      i0 => REN(0),
      i1 => REN(1),
      i2 => REN(2),
      o  => IDLE_A );

  iIDLE1 : lut3
    --pragma translate_off
    generic map (init => initv_01)
    --pragma translate_on
    port map (
      i0 => REN(3),
      i1 => REN(4),
      i2 => REN(5),
      o  => IDLE_B );

  iIDLE2 : lut4
    --pragma translate_off
    generic map (init => initv_0002)
    --pragma translate_on
    port map (
      i0 => IDLE_B,
      i1 => REN(0),
      i2 => REN(1),
      i3 => REN(2),
      o  => IDLE );

  IDLEv <= (IDLE & IDLE & IDLE & IDLE & IDLE & IDLE);

--READY <= (INFIFO_READ_REQ AND EF_REG) OR (INFIFO_READ_REQ AND DRBV);

  iREADY0 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(0),
      i1 => EF_REG(0),
      i2 => DRBV(0),
      o  => READY(0) );

  iREADY1 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(1),
      i1 => EF_REG(1),
      i2 => DRBV(1),
      o  => READY(1) );

  iREADY2 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(2),
      i1 => EF_REG(2),
      i2 => DRBV(2),
      o  => READY(2) );

  iREADY3 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(3),
      i1 => EF_REG(3),
      i2 => DRBV(3),
      o  => READY(3) );

  iREADY4 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(4),
      i1 => EF_REG(4),
      i2 => DRBV(4),
      o  => READY(4) );

  iREADY5 : lut3
    --pragma translate_off
    generic map (init => initv_a8)
    --pragma translate_on
    port map (
      i0 => INFIFO_READ_REQ(5),
      i1 => EF_REG(5),
      i2 => DRBV(5),
      o  => READY(5) );

--RDY_FN0 <= READY(2) OR READY(3) OR READY(4) OR READY(5);
--RDY_FN1 <= READY(0) OR READY(1) OR READY(4) OR READY(5);
--RDY_FN2 <= READY(0) OR READY(1) OR READY(2) OR READY(3);

  iRDY_F0 : lut4
    --pragma translate_off
    generic map (init => initv_fffe)
    --pragma translate_on
    port map (
      i0 => READY(2),
      i1 => READY(3),
      i2 => READY(4),
      i3 => READY(5),
      o  => RDY_FN0 );

  iRDY_F1 : lut4
    --pragma translate_off
    generic map (init => initv_fffe)
    --pragma translate_on
    port map (
      i0 => READY(0),
      i1 => READY(1),
      i2 => READY(4),
      i3 => READY(5),
      o  => RDY_FN1 );

  iRDY_F2 : lut4
    --pragma translate_off
    generic map (init => initv_fffe)
    --pragma translate_on
    port map (
      i0 => READY(0),
      i1 => READY(1),
      i2 => READY(2),
      i3 => READY(3),
      o  => RDY_FN2 );

--RDY_FN3 <= (NOT INFIFO_READ_REQ(0)) OR READY(1);
--RDY_FN4 <= (NOT INFIFO_READ_REQ(1)) OR READY(0);
--RDY_FN5 <= (NOT INFIFO_READ_REQ(2)) OR READY(3);
--RDY_FN6 <= (NOT INFIFO_READ_REQ(3)) OR READY(2);
--RDY_FN7 <= (NOT INFIFO_READ_REQ(4)) OR READY(5);
--RDY_FN8 <= (NOT INFIFO_READ_REQ(5)) OR READY(4);

  iRDY_F3 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(1),
      i1 => INFIFO_READ_REQ(0),
      o  => RDY_FN3 );

  iRDY_F4 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(0),
      i1 => INFIFO_READ_REQ(1),
      o  => RDY_FN4 );

  iRDY_F5 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(3),
      i1 => INFIFO_READ_REQ(2),
      o  => RDY_FN5 );

  iRDY_F6 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(2),
      i1 => INFIFO_READ_REQ(3),
      o  => RDY_FN6 );

  iRDY_F7 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(5),
      i1 => INFIFO_READ_REQ(4),
      o  => RDY_FN7 );

  iRDY_F8 : lut2
    --pragma translate_off
    generic map (init => initv_b)
    --pragma translate_on
    port map (
      i0 => READY(4),
      i1 => INFIFO_READ_REQ(5),
      o  => RDY_FN8 );

--CURR_RDY(0) <= CURR_FIFO(0) AND (NOT READY(1)) AND (NOT RDY_FN0);
--CURR_RDY(1) <= CURR_FIFO(1) AND (NOT READY(0)) AND (NOT RDY_FN0);
--CURR_RDY(2) <= CURR_FIFO(2) AND (NOT READY(3)) AND (NOT RDY_FN1);
--CURR_RDY(3) <= CURR_FIFO(3) AND (NOT READY(2)) AND (NOT RDY_FN1);
--CURR_RDY(4) <= CURR_FIFO(4) AND (NOT READY(5)) AND (NOT RDY_FN2);
--CURR_RDY(5) <= CURR_FIFO(5) AND (NOT READY(4)) AND (NOT RDY_FN2);

  iCRDY0 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => READY(1),
      i2 => RDY_FN0,
      o  => CURR_RDY(0) );

  iCRDY1 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => READY(0),
      i2 => RDY_FN0,
      o  => CURR_RDY(1) );

  iCRDY2 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => READY(3),
      i2 => RDY_FN1,
      o  => CURR_RDY(2) );

  iCRDY3 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => READY(2),
      i2 => RDY_FN1,
      o  => CURR_RDY(3) );

  iCRDY4 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => READY(5),
      i2 => RDY_FN2,
      o  => CURR_RDY(4) );

  iCRDY5 : lut3
    --pragma translate_off
    generic map (init => initv_02)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(5),
      i1 => READY(4),
      i2 => RDY_FN2,
      o  => CURR_RDY(5) );

  iCMA0 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => INFIFO_READ_REQ(0),
      i2 => EF_REG(0),
      i3 => DRBV(0),
      lo => CMUX_A(0) );

  iCMA1 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => INFIFO_READ_REQ(1),
      i2 => EF_REG(1),
      i3 => DRBV(1),
      lo => CMUX_A(1) );

  iCMA2 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => INFIFO_READ_REQ(2),
      i2 => EF_REG(2),
      i3 => DRBV(2),
      lo => CMUX_A(2) );

  iCMA3 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => INFIFO_READ_REQ(3),
      i2 => EF_REG(3),
      i3 => DRBV(3),
      lo => CMUX_A(3) );

  iCMA4 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => INFIFO_READ_REQ(4),
      i2 => EF_REG(4),
      i3 => DRBV(4),
      lo => CMUX_A(4) );

  iCMA5 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(5),
      i1 => INFIFO_READ_REQ(5),
      i2 => EF_REG(5),
      i3 => DRBV(5),
      lo => CMUX_A(5) );

  iCMB0 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(0),
      i1 => INFIFO_READ_REQ(0),
      i2 => EF_REG(0),
      i3 => DRBV(0),
      lo => CMUX_B(0) );

  iCMB1 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(1),
      i1 => INFIFO_READ_REQ(1),
      i2 => EF_REG(1),
      i3 => DRBV(1),
      lo => CMUX_B(1) );

  iCMB2 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(2),
      i1 => INFIFO_READ_REQ(2),
      i2 => EF_REG(2),
      i3 => DRBV(2),
      lo => CMUX_B(2) );

  iCMB3 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(3),
      i1 => INFIFO_READ_REQ(3),
      i2 => EF_REG(3),
      i3 => DRBV(3),
      lo => CMUX_B(3) );

  iCMB4 : lut4_l
    --pragma translate_off
    generic map (init => initv_1115)
    --pragma translate_on
    port map (
      i0 => CURR_FIFO(4),
      i1 => INFIFO_READ_REQ(4),
      i2 => EF_REG(4),
      i3 => DRBV(4),
      lo => CMUX_B(4) );

  CARRY_A(0) <= '1';

--CMUX_B <= CURR_FIFO NOR READY;

  iCMUX11 : MUXCY_L port map (CARRY_A(1), DI=>CURR_FIFO(0), CI=>CARRY_A(0), S=>CMUX_A(0));
  iCMUX12 : MUXCY_L port map (CARRY_A(2), DI=>CURR_FIFO(1), CI=>CARRY_A(1), S=>CMUX_A(1));
  iCMUX13 : MUXCY_L port map (CARRY_A(3), DI=>CURR_FIFO(2), CI=>CARRY_A(2), S=>CMUX_A(2));
  iCMUX14 : MUXCY_L port map (CARRY_A(4), DI=>CURR_FIFO(3), CI=>CARRY_A(3), S=>CMUX_A(3));
  iCMUX15 : MUXCY_L port map (CARRY_A(5), DI=>CURR_FIFO(4), CI=>CARRY_A(4), S=>CMUX_A(4));

  iCMUX0  : MUXCY_L port map (CARRY_B(0), DI=>CURR_FIFO(5), CI=>CARRY_A(5), S=>CMUX_A(5));
  iCMUX1  : MUXCY_L port map (CARRY_B(1), DI=>CURR_FIFO(0), CI=>CARRY_B(0), S=>CMUX_B(0));
  iCMUX2  : MUXCY_L port map (CARRY_B(2), DI=>CURR_FIFO(1), CI=>CARRY_B(1), S=>CMUX_B(1));
  iCMUX3  : MUXCY_L port map (CARRY_B(3), DI=>CURR_FIFO(2), CI=>CARRY_B(2), S=>CMUX_B(2));
  iCMUX4  : MUXCY_L port map (CARRY_B(4), DI=>CURR_FIFO(3), CI=>CARRY_B(3), S=>CMUX_B(3));
  iCMUX5  : MUXCY_L port map (CARRY_B(5), DI=>CURR_FIFO(4), CI=>CARRY_B(4), S=>CMUX_B(4));

--NEXT_FIFO <= CARRY_B AND READY;

  iNEXT0 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(0),
      i1 => CARRY_B(0),
      o  => NEXT_FIFO(0) );

  iNEXT1 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(1),
      i1 => CARRY_B(1),
      o  => NEXT_FIFO(1) );

  iNEXT2 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(2),
      i1 => CARRY_B(2),
      o  => NEXT_FIFO(2) );

  iNEXT3 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(3),
      i1 => CARRY_B(3),
      o  => NEXT_FIFO(3) );

  iNEXT4 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(4),
      i1 => CARRY_B(4),
      o  => NEXT_FIFO(4) );

  iNEXT5 : lut2
    --pragma translate_off
    generic map (init => initv_8)
    --pragma translate_on
    port map (
      i0 => READY(5),
      i1 => CARRY_B(5),
      o  => NEXT_FIFO(5) );

  iCURR0 : FDCE port map (CURR_FIFO(0), D=>NEXT_FIFO(0), C=>CLK, CE=>CHANGE, CLR=>RST);
  iCURR1 : FDCE port map (CURR_FIFO(1), D=>NEXT_FIFO(1), C=>CLK, CE=>CHANGE, CLR=>RST);
  iCURR2 : FDCE port map (CURR_FIFO(2), D=>NEXT_FIFO(2), C=>CLK, CE=>CHANGE, CLR=>RST);
  iCURR3 : FDCE port map (CURR_FIFO(3), D=>NEXT_FIFO(3), C=>CLK, CE=>CHANGE, CLR=>RST);
  iCURR4 : FDCE port map (CURR_FIFO(4), D=>NEXT_FIFO(4), C=>CLK, CE=>CHANGE, CLR=>RST);
  iCURR5 : FDPE port map (CURR_FIFO(5), D=>NEXT_FIFO(5), C=>CLK, CE=>CHANGE, PRE=>RST);

end RTL;


