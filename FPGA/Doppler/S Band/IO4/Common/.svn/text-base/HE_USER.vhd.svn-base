-- ==============================================================
-- FILE : HE_USER.VHD  -  DO NOT EDIT THIS FILE
-- ==============================================================
--
-- This file is part of the Hardware Interface Layer (H.I.L) of
-- your project when using your HERON-IO4 module.
--
-- This file must NOT be modified by users of the Module.
--
-- ==============================================================
--
--  Module      : HE_USER
--  Date        : 04/03/2002
--  Author      : R. Williams - HUNT ENGINEERING
--  Description : HUNT Serial Bus interface
--
-- ==============================================================
--
--  Ver     Modified By      Date      Changes
--  ---     -----------      ----      -------
--  1.0     R. Williams    04-03-02    First Written
--  1.1     R. Williams    08-05-02    Syntax change made to all
--                                     instanciated components,
--                                     (changed '0' to GND)
--                                     for compatibility with
--                                     ModelSim5.5b.
--  2.0     R. Williams    26-11-02    New components added for
--                                     interfacing to all six HERON
--                                     input FIFOs and all six HERON
--                                     output FIFOs at the same time.
--                                     Added component HE_RD_6F in
--                                     place of component HE_RD_1F.
--                                     Added component HE_WR_6F in
--                                     place of component HE_WR_1F.
--  2.1     R. Williams    20-01-03    Changes made to the HSB
--                                     mastering functions, and 
--                                     additional registering added
--                                     to the AE flag to ensure
--                                     correct reading from HEPC8s.
--
-- ==============================================================


library IEEE;
  use IEEE.std_logic_1164.all;
  use ieee.std_logic_arith.all;
  use ieee.std_logic_unsigned.all;

-- synopsys translate_off
library UNISIM;
  use UNISIM.vcomponents.all;
-- synopsys translate_on

entity HE_USER is
  port (
    -- External PADS - HE_V/S_CTL
    VPD       : inout std_logic_vector(7 downto 0);
    VINIT     : inout std_logic;  -- ADDR strobe, active low
    VCS       : inout std_logic;  -- DATA strobe, active low
    VWRITE    : inout std_logic;  -- WRITE command, active low
    VBUSY     : inout std_logic;  -- BUSY status, active low
    -- Module I/Os
    RST       : in  std_logic;
    CLK       : in  std_logic;
    READY     : in  std_logic;
    SEND_MSG  : in  std_logic;
    CE        : in  std_logic;
    DOUT      : in  std_logic_vector(7 downto 0);
    CID       : in  std_logic_vector(3 downto 0);
    MID       : in  std_logic_vector(2 downto 0);
    SEND_ID   : in  std_logic;
    LAST_BYTE : in  std_logic;
    DIN       : out std_logic_vector(7 downto 0);
    ADDR      : out std_logic_vector(7 downto 0);
    WEN       : out std_logic;
    REN       : out std_logic;
    DONE      : out std_logic;
    COUNT     : out std_logic;
    CLEAR     : out std_logic
  );
end HE_USER;


architecture RTL of HE_USER is

  component FD
    port(
      Q : out std_logic;
      D : in  std_logic;
      C : in  std_logic );
  end component;

  signal INIT_CONF : std_logic := '0';  -- for simulation only !
  signal VCC       : std_logic;

  signal iREADY     : std_logic;
  signal iSEND_MSG  : std_logic;
  signal iCE        : std_logic;
  signal iDOUT      : std_logic_vector(7 downto 0);
  signal iCID       : std_logic_vector(3 downto 0);
  signal iMID       : std_logic_vector(2 downto 0);
  signal iSEND_ID   : std_logic;
  signal iLAST_BYTE : std_logic;

  signal DATA     : std_logic_vector(7 downto 0);
  signal DINi     : std_logic_vector(7 downto 0);
  signal LD_ADDR  : std_logic;
  signal LD_DATA  : std_logic;
  signal SEND     : std_logic;
  signal OE       : std_logic;
  signal STOP     : std_logic;
  signal FF_REG   : std_logic;
  signal BUS_FREE : std_logic;
  signal LB_REG   : std_logic;
  signal EN_A     : std_logic;
  signal EN_B     : std_logic;
  signal CLEARi   : std_logic;
  signal BUSY     : std_logic;
  signal ASTRB    : std_logic;
  signal DSTRB    : std_logic;
  signal WRITE    : std_logic;
  signal FULL     : std_logic;
  signal OEN      : std_logic;
  signal ADDR_EN  : std_logic;
  signal LA_RG    : std_logic;
  signal LD_RG    : std_logic;
  signal SD_RG    : std_logic;
  signal BY_RG    : std_logic;
  signal LA_OEN   : std_logic;
  signal LD_OEN   : std_logic;
  signal SD_OEN   : std_logic;
  signal BY_OEN   : std_logic;
  signal F        : std_logic_vector(9 downto 0);
  signal S        : std_logic_vector(1 downto 0);
  signal ID       : std_logic_vector(7 downto 0);
  signal D        : std_logic_vector(7 downto 0);
  signal Q        : std_logic_vector(7 downto 0);

  signal CLR_LB_REG : std_logic;

begin

  VCC <= '1';

  -- Delay input signals for 1 simulation delta
  -- This is to ensure correctness of functional simulation
  iREADY     <= READY;
  iSEND_MSG  <= SEND_MSG;
  iCE        <= CE;
  iDOUT      <= DOUT;
  iCID       <= CID;
  iMID       <= MID;
  iSEND_ID   <= SEND_ID;
  iLAST_BYTE <= LAST_BYTE;

  -- At the end of FPGA configuration only (not when RST active), VBUSY must be forced to 0
  -- INIT_CONF is a signal set to 0 at startup, 1 at the first clock cycle, and then never reset.
  -- INIT_CONF is then used to set the initial level of VBUSY
  iCONF : FD port map (Q=>INIT_CONF, D=>VCC, C=>CLK);

  -- HE_S/V_UIO
  -- ==========
  OEN <= NOT((LD_DATA AND WRITE AND (NOT DSTRB)) OR (NOT OE));

  process(RST, CLK)
  begin
    if RST='1' then
      ADDR_EN  <= '0';  -- added async reset
      WEN      <= '0';  -- added async reset
      REN      <= '0';  -- added async reset
      BUS_FREE <= '0';  -- added async reset
    elsif rising_edge(CLK) then
      ADDR_EN  <= LD_ADDR AND (NOT ASTRB);
      WEN      <= LD_DATA AND (NOT WRITE) AND (NOT DSTRB);
      REN      <= LD_DATA AND WRITE AND (NOT DSTRB);
      BUS_FREE <= ASTRB AND DSTRB AND WRITE;
    end if;
  end process;

  STOP <= ADDR_EN;

  BUSY <= (NOT iREADY) AND INIT_CONF;

  process(RST, CLK)
  begin
    if RST='1' then
      ADDR <= (others=>'0');  -- added async reset
    elsif rising_edge(CLK) then
      if ADDR_EN='1' then
        ADDR <= DINi;
      end if;
    end if;
  end process;

  process(RST, CLK)
  begin
    if RST='1' then
      FF_REG <= '0';  -- added async reset
    elsif rising_edge(CLK) then
      FF_REG <= FULL;
    end if;
  end process;

  -- HE_V/S_CTL
  VPD <= DATA when OEN='0' else (others=>'Z');
  DINi <= VPD;
  DIN <= DINi;

  -- HE_V/S_TRIO
  process(RST, CLK)
  begin
    if RST='1' then
      LA_RG <= '1';  -- added async reset (init value modified)
      LD_RG <= '1';  -- added async reset (init value modified)
      SD_RG <= '1';  -- added async reset (init value modified)
      BY_RG <= '1';  -- added async reset (init value modified)
    elsif rising_edge(CLK) then
      LA_RG <= LD_ADDR;
      LD_RG <= LD_DATA;
      SD_RG <= SEND;
      BY_RG <= BUSY;
    end if;
  end process;

  LA_OEN <= LA_RG AND LD_ADDR;
  LD_OEN <= LD_RG AND LD_DATA;
  SD_OEN <= SD_RG AND SEND;
  BY_OEN <= (BY_RG AND INIT_CONF) AND BUSY;

  VINIT <= LD_ADDR when LA_OEN='0' else 'Z';
  ASTRB <= VINIT;
  VCS <= LD_DATA when LD_OEN='0' else 'Z';
  DSTRB <= VCS;
  VWRITE <= SEND when SD_OEN='0' else 'Z';
  WRITE <= VWRITE;
  VBUSY <= BUSY when BY_OEN='0' else 'Z';
  FULL <= VBUSY;

  -- HE_U_MSG  --  State Machine
  F(0) <= iSEND_MSG AND BUS_FREE AND SEND AND (NOT S(0)) AND (NOT S(1));
  F(1) <= STOP AND (NOT SEND) AND (NOT S(0)) AND (NOT S(1));
  F(2) <= iSEND_MSG AND SEND AND S(0) AND S(1);
  F(3) <= S(1) AND (NOT SEND);
  F(4) <= SEND AND S(0) AND (NOT S(1));
  F(5) <= F(7) AND FF_REG AND (NOT LB_REG);
  F(6) <= S(1) AND (NOT S(0));
  F(7) <= (NOT SEND) AND (NOT S(0)) AND (NOT S(1));
  F(8) <= S(0) AND (NOT SEND);
  F(9) <= (NOT SEND) AND S(1) AND (NOT S(0));

  process(RST, CLK)
  begin
    if RST='1' then
      S <= "00";
    elsif rising_edge(CLK) then
      if iCE='1' then
        S(0) <= F(0) OR F(1) OR F(2) OR F(3);
        S(1) <= F(1) OR F(2) OR F(4) OR F(5) OR F(9);
      end if;
    end if;
  end process;

  COUNT <= iCE AND S(1) AND (NOT S(0));

  EN_A <= (iCE AND S(0) AND (NOT S(1))) OR (iCE AND (NOT S(1)) AND (NOT SEND));

  EN_B <= iCE AND (NOT SEND) AND S(1) AND (NOT S(0));

  OE <= NOT ((S(0) XOR S(1)) OR (NOT SEND));

  process(RST, CLK)
  begin
    if RST='1'then
      DONE <= '0';  -- added async reset
    elsif rising_edge(CLK) then
      if iCE='1' then
        DONE <= F(7) AND FF_REG AND LB_REG AND (NOT STOP);
      end if;
    end if;
  end process;

  process(RST, CLK)
  begin
    if RST='1' then
      SEND <= '1';
    elsif rising_edge(CLK) then
      if iCE='1' then
        SEND <= NOT(F(6) OR F(8) OR (F(7) AND (NOT FF_REG) AND (NOT STOP)) OR (F(7) AND (NOT LB_REG) AND (NOT STOP)));
      end if;
    end if;
  end process;

  process(RST, CLK)
  begin
    if RST='1' then
      LD_ADDR <= '1';  -- added async preset
      LD_DATA <= '1';  -- added async preset
    elsif rising_edge(CLK) then
      if iCE='1' then
        LD_ADDR <= NOT F(4);
        LD_DATA <= NOT F(5);
      end if;
    end if;
  end process;

  process(RST, CLK)
  begin
    if RST='1' then
      CLEARi <= '0';
    elsif rising_edge(CLK) then
      if iCE='1' then
        CLEARi <= F(0);
      end if;
    end if;
  end process;
  CLEAR <= CLEARi;

  -- HE_U_DATA
  -- =========

  CLR_LB_REG <= CLEARi OR RST;  -- added RST as async reset

  process(CLR_LB_REG, CLK)
  begin
    if CLR_LB_REG='1' then
      LB_REG <= '0';
    elsif rising_edge(CLK) then
      if EN_B='1' then
        LB_REG <= iLAST_BYTE;
      end if;
    end if;
  end process;

  ID <= '0' & iCID & iMID;
  D <= iDOUT when iSEND_ID='0' else ID;

  process(RST, CLK)
  begin
    if RST='1' then
      Q <= (others=>'0');  -- added async reset
    elsif rising_edge(CLK) then
      if EN_A='1' then
        Q <= D;
      end if;
    end if;
  end process;

  DATA <= Q when OE='0' else iDOUT;

end RTL;

